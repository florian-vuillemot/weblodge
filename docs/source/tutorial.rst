Tutorial
========

In this tutorial, we will learn how to use **WebLodge** to deploy a simple application.


Standard application
********************

Here the application we will deploy:

.. code-block:: console

   $ cat app.py  # The application entry point.
   from flask import Flask

   app = Flask(__name__)  # The Flask application.

   @app.route("/")
   def hello_world():
      return "<p>Hello, World!</p>"
   $
   $ cat requirements.txt  # The application dependencies.
   Flask

You can deploy this application by doing:

.. code-block:: console

   $ # Install WebLodge.
   $ pip install weblodge

   $ # Build the application.
   $ weblodge build
   $ weblodge deploy
   ...
   The application will soon be available at: https://weblodge-tutorial.azurewebsites.net

   $ # But you can also Build and deploy the application in single command.
   $ weblodge deploy --build
   ...
   The application will soon be available at: https://weblodge-tutorial.azurewebsites.net

During the build phase, **WebLodge** will create a folder with the application built
and other files needed to deploy the application. This private folder does not need
to be versioned and can be ignored by your version control system.

During the deployment phase, **WebLodge** will create a `.weblodge.json` file
that contains the configuration of the application. This file can be version control.
To be available on the internet, the application needs a subdomain -- here `weblodge-tutorial` --.
This subdomain is unique Azure. It can be provided by passing the `--subdomain` option or will be
automatically generated by **WebLodge**.

After a couple of seconds, the application will be available at the given subdomain
and can be accessible from your browser.

.. note::

    The `.weblodge.json` contains the subdomain of the application. This subdomain
    is unique Azure. It can be already used by another application. and may be
    unavailable. If this is the case, you can change the subdomain in the
    `.weblodge.json` file and redeploy the application.

.. warning::

    By default, **WebLodge** will deploy free resources. This means that the application
    will be shutdown by Azure after a couple of minutes of inactivity and the usage will be
    limited per day. You can change this behavior by passing the `--sku` option.


Adding environment variables
****************************

Your application may use environment variables containing dynamic values or secrets.
For example, we can update the `app.py` file to return a message that depends on the `MESSAGE`
environment variable:

.. code-block:: console

    $ cat app.py
    import os
    from flask import Flask

    app = Flask(__name__)  # The Flask application.

    @app.route("/")
    def hello_world():
      return f"<p>Hello, {os.environ['MESSAGE']}!</p>"


By default, **WebLodge** will look if the `.env` file exists, and if so, use it for environment variables.
You can also specify this file by using the `--env-file` option:

.. code-block:: console

    $ cat .env
    MESSAGE=World
    $ # Deploy the application using the `.env` file.
    $ webloge deploy

    $ cat .prod
    MESSAGE=Guido
    $ # Deploy the application using the `.prod` file.
    $ webloge deploy --env-file .prod

.. note::

    Environment file are defined during the deployment phase. You don't need to rebuild the application.

Behind the wood, **WebLodge** is using the `python-dotenv`_ package to load the environment variables.
Feel free to use it's features.

.. _python-dotenv: https://pypi.org/project/python-dotenv


Deleting the infrastructure
***************************

You can delete the previously deployed infrastructure by doing:

.. code-block:: console

    $ # With the validation prompt.
    $ weblodge delete
    Do you want to delete the application 'weblodge-tutorial' (yes/no.)?

    $ # Without the validation prompt.
    $ weblodge delete --yes
